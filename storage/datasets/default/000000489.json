{
	"title": "Tool Input Schema | 🦜️🔗 Langchain",
	"url": "https://python.langchain.com/docs/modules/agents/tools/tool_input_validation",
	"html": "ModulesAgentsToolsTool Input Schema\nTool Input Schema\n\nBy default, tools infer the argument schema by inspecting the function signature. For more strict requirements, custom input schema can be specified, along with custom validation logic.\n\nfrom typing import Any, Dict\n\nfrom langchain.agents import AgentType, initialize_agent\nfrom langchain.llms import OpenAI\nfrom langchain.tools.requests.tool import RequestsGetTool, TextRequestsWrapper\nfrom pydantic import BaseModel, Field, root_validator\n\nllm = OpenAI(temperature=0)\n\npip install tldextract > /dev/null\n\n    \n    [notice] A new release of pip is available: 23.0.1 -> 23.1\n    [notice] To update, run: pip install --upgrade pip\n\nimport tldextract\n\n_APPROVED_DOMAINS = {\n    \"langchain\",\n    \"wikipedia\",\n}\n\n\nclass ToolInputSchema(BaseModel):\n    url: str = Field(...)\n\n    @root_validator\n    def validate_query(cls, values: Dict[str, Any]) -> Dict:\n        url = values[\"url\"]\n        domain = tldextract.extract(url).domain\n        if domain not in _APPROVED_DOMAINS:\n            raise ValueError(\n                f\"Domain {domain} is not on the approved list:\"\n                f\" {sorted(_APPROVED_DOMAINS)}\"\n            )\n        return values\n\n\ntool = RequestsGetTool(\n    args_schema=ToolInputSchema, requests_wrapper=TextRequestsWrapper()\n)\n\nagent = initialize_agent(\n    [tool], llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=False\n)\n\n# This will succeed, since there aren't any arguments that will be triggered during validation\nanswer = agent.run(\"What's the main title on langchain.com?\")\nprint(answer)\n\n    The main title of langchain.com is \"LANG CHAIN 🦜️🔗 Official Home Page\"\n\nagent.run(\"What's the main title on google.com?\")\n\n    ---------------------------------------------------------------------------\n\n    ValidationError                           Traceback (most recent call last)\n\n    Cell In[7], line 1\n    ----> 1 agent.run(\"What's the main title on google.com?\")\n\n\n    File ~/code/lc/lckg/langchain/chains/base.py:213, in Chain.run(self, *args, **kwargs)\n        211     if len(args) != 1:\n        212         raise ValueError(\"`run` supports only one positional argument.\")\n    --> 213     return self(args[0])[self.output_keys[0]]\n        215 if kwargs and not args:\n        216     return self(kwargs)[self.output_keys[0]]\n\n\n    File ~/code/lc/lckg/langchain/chains/base.py:116, in Chain.__call__(self, inputs, return_only_outputs)\n        114 except (KeyboardInterrupt, Exception) as e:\n        115     self.callback_manager.on_chain_error(e, verbose=self.verbose)\n    --> 116     raise e\n        117 self.callback_manager.on_chain_end(outputs, verbose=self.verbose)\n        118 return self.prep_outputs(inputs, outputs, return_only_outputs)\n\n\n    File ~/code/lc/lckg/langchain/chains/base.py:113, in Chain.__call__(self, inputs, return_only_outputs)\n        107 self.callback_manager.on_chain_start(\n        108     {\"name\": self.__class__.__name__},\n        109     inputs,\n        110     verbose=self.verbose,\n        111 )\n        112 try:\n    --> 113     outputs = self._call(inputs)\n        114 except (KeyboardInterrupt, Exception) as e:\n        115     self.callback_manager.on_chain_error(e, verbose=self.verbose)\n\n\n    File ~/code/lc/lckg/langchain/agents/agent.py:792, in AgentExecutor._call(self, inputs)\n        790 # We now enter the agent loop (until it returns something).\n        791 while self._should_continue(iterations, time_elapsed):\n    --> 792     next_step_output = self._take_next_step(\n        793         name_to_tool_map, color_mapping, inputs, intermediate_steps\n        794     )\n        795     if isinstance(next_step_output, AgentFinish):\n        796         return self._return(next_step_output, intermediate_steps)\n\n\n    File ~/code/lc/lckg/langchain/agents/agent.py:695, in AgentExecutor._take_next_step(self, name_to_tool_map, color_mapping, inputs, intermediate_steps)\n        693         tool_run_kwargs[\"llm_prefix\"] = \"\"\n        694     # We then call the tool on the tool input to get an observation\n    --> 695     observation = tool.run(\n        696         agent_action.tool_input,\n        697         verbose=self.verbose,\n        698         color=color,\n        699         **tool_run_kwargs,\n        700     )\n        701 else:\n        702     tool_run_kwargs = self.agent.tool_run_logging_kwargs()\n\n\n    File ~/code/lc/lckg/langchain/tools/base.py:110, in BaseTool.run(self, tool_input, verbose, start_color, color, **kwargs)\n        101 def run(\n        102     self,\n        103     tool_input: Union[str, Dict],\n       (...)\n        107     **kwargs: Any,\n        108 ) -> str:\n        109     \"\"\"Run the tool.\"\"\"\n    --> 110     run_input = self._parse_input(tool_input)\n        111     if not self.verbose and verbose is not None:\n        112         verbose_ = verbose\n\n\n    File ~/code/lc/lckg/langchain/tools/base.py:71, in BaseTool._parse_input(self, tool_input)\n         69 if issubclass(input_args, BaseModel):\n         70     key_ = next(iter(input_args.__fields__.keys()))\n    ---> 71     input_args.parse_obj({key_: tool_input})\n         72 # Passing as a positional argument is more straightforward for\n         73 # backwards compatability\n         74 return tool_input\n\n\n    File ~/code/lc/lckg/.venv/lib/python3.11/site-packages/pydantic/main.py:526, in pydantic.main.BaseModel.parse_obj()\n\n\n    File ~/code/lc/lckg/.venv/lib/python3.11/site-packages/pydantic/main.py:341, in pydantic.main.BaseModel.__init__()\n\n\n    ValidationError: 1 validation error for ToolInputSchema\n    __root__\n      Domain google is not on the approved list: ['langchain', 'wikipedia'] (type=value_error)\n\nPrevious\nMulti-Input Tools\nNext\nTools as OpenAI Functions"
}