{
	"title": "Redis | ğŸ¦œï¸ğŸ”— Langchain",
	"url": "https://python.langchain.com/docs/integrations/vectorstores/redis",
	"html": "ComponentsVector storesRedis\nRedis\n\nRedis vector database introduction and langchain integration guide.\n\nWhat is Redis?â€‹\n\nMost developers from a web services background are probably familiar with Redis. At it's core, Redis is an open-source key-value store that can be used as a cache, message broker, and database. Developers choose Redis because it is fast, has a large ecosystem of client libraries, and has been deployed by major enterprises for years.\n\nOn top of these traditional use cases, Redis provides additional capabilities like the Search and Query capability that allows users to create secondary index structures within Redis. This allows Redis to be a Vector Database, at the speed of a cache.\n\nRedis as a Vector Databaseâ€‹\n\nRedis uses compressed, inverted indexes for fast indexing with a low memory footprint. It also supports a number of advanced features such as:\n\nIndexing of multiple fields in Redis hashes and JSON\nVector similarity search (with HNSW (ANN) or FLAT (KNN))\nVector Range Search (e.g. find all vectors within a radius of a query vector)\nIncremental indexing without performance loss\nDocument ranking (using tf-idf, with optional user-provided weights)\nField weighting\nComplex boolean queries with AND, OR, and NOT operators\nPrefix matching, fuzzy matching, and exact-phrase queries\nSupport for double-metaphone phonetic matching\nAuto-complete suggestions (with fuzzy prefix suggestions)\nStemming-based query expansion in many languages (using Snowball)\nSupport for Chinese-language tokenization and querying (using Friso)\nNumeric filters and ranges\nGeospatial searches using Redis geospatial indexing\nA powerful aggregations engine\nSupports for all utf-8 encoded text\nRetrieve full documents, selected fields, or only the document IDs\nSorting results (for example, by creation date)\nClientsâ€‹\n\nSince redis is much more than just a vector database, there are often use cases that demand usage of a Redis client besides just the langchain integration. You can use any standard Redis client library to run Search and Query commands, but it's easiest to use a library that wraps the Search and Query API. Below are a few examples, but you can find more client libraries here.\n\nProject\tLanguage\tLicense\tAuthor\tStars\njedis\tJava\tMIT\tRedis\t\nredisvl\tPython\tMIT\tRedis\t\nredis-py\tPython\tMIT\tRedis\t\nnode-redis\tNode.js\tMIT\tRedis\t\nnredisstack\t.NET\tMIT\tRedis\t\nDeployment Optionsâ€‹\n\nThere are many ways to deploy Redis with RediSearch. The easiest way to get started is to use Docker, but there are are many potential options for deployment such as\n\nRedis Cloud\nDocker (Redis Stack)\nCloud marketplaces: AWS Marketplace, Google Marketplace, or Azure Marketplace\nOn-premise: Redis Enterprise Software\nKubernetes: Redis Enterprise Software on Kubernetes\nExamplesâ€‹\n\nMany examples can be found in the Redis AI team's GitHub\n\nAwesome Redis AI Resources - List of examples of using Redis in AI workloads\nAzure OpenAI Embeddings Q&A - OpenAI and Redis as a Q&A service on Azure.\nArXiv Paper Search - Semantic search over arXiv scholarly papers\nVector Search on Azure - Vector search on Azure using Azure Cache for Redis and Azure OpenAI\nMore Resourcesâ€‹\n\nFor more information on how to use Redis as a vector database, check out the following resources:\n\nRedisVL Documentation - Documentation for the Redis Vector Library Client\nRedis Vector Similarity Docs - Redis official docs for Vector Search.\nRedis-py Search Docs - Documentation for redis-py client library\nVector Similarity Search: From Basics to Production - Introductory blog post to VSS and Redis as a VectorDB.\nInstall Redis Python Clientâ€‹\n\nRedis-py is the officially supported client by Redis. Recently released is the RedisVL client which is purpose-built for the Vector Database use cases. Both can be installed with pip.\n\npip install redis redisvl openai tiktoken\n\n\nWe want to use OpenAIEmbeddings so we have to get the OpenAI API Key.\n\nimport getpass\nimport os\n\nos.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"OpenAI API Key:\")\n\nfrom langchain.embeddings import OpenAIEmbeddings\n\nembeddings = OpenAIEmbeddings()\n\nSample Dataâ€‹\n\nFirst we will describe some sample data so that the various attributes of the Redis vector store can be demonstrated.\n\nmetadata = [\n    {\n        \"user\": \"john\",\n        \"age\": 18,\n        \"job\": \"engineer\",\n        \"credit_score\": \"high\",\n    },\n    {\n        \"user\": \"derrick\",\n        \"age\": 45,\n        \"job\": \"doctor\",\n        \"credit_score\": \"low\",\n    },\n    {\n        \"user\": \"nancy\",\n        \"age\": 94,\n        \"job\": \"doctor\",\n        \"credit_score\": \"high\",\n    },\n    {\n        \"user\": \"tyler\",\n        \"age\": 100,\n        \"job\": \"engineer\",\n        \"credit_score\": \"high\",\n    },\n    {\n        \"user\": \"joe\",\n        \"age\": 35,\n        \"job\": \"dentist\",\n        \"credit_score\": \"medium\",\n    },\n]\ntexts = [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"]\n\nInitializing Redisâ€‹\n\nTo locally deploy Redis, run:\n\ndocker run -d -p 6379:6379 -p 8001:8001 redis/redis-stack:latest\n\n\nIf things are running correctly you should see a nice Redis UI at http://localhost:8001. See the Deployment Options section above for other ways to deploy.\n\nThe Redis VectorStore instance can be initialized in a number of ways. There are multiple class methods that can be used to initialize a Redis VectorStore instance.\n\nRedis.__init__ - Initialize directly\nRedis.from_documents - Initialize from a list of Langchain.docstore.Document objects\nRedis.from_texts - Initialize from a list of texts (optionally with metadata)\nRedis.from_texts_return_keys - Initialize from a list of texts (optionally with metadata) and return the keys\nRedis.from_existing_index - Initialize from an existing Redis index\n\nBelow we will use the Redis.from_texts method.\n\nfrom langchain.vectorstores.redis import Redis\n\nrds = Redis.from_texts(\n    texts,\n    embeddings,\n    metadatas=metadata,\n    redis_url=\"redis://localhost:6379\",\n    index_name=\"users\",\n)\n\nrds.index_name\n\n    'users'\n\nInspecting the Created Indexâ€‹\n\nOnce the Redis VectorStore object has been constructed, an index will have been created in Redis if it did not already exist. The index can be inspected with both the rvland the redis-cli command line tool. If you installed redisvl above, you can use the rvl command line tool to inspect the index.\n\n# assumes you're running Redis locally (use --host, --port, --password, --username, to change this)\nrvl index listall\n\n    16:58:26 [RedisVL] INFO   Indices:\n    16:58:26 [RedisVL] INFO   1. users\n\n\nThe Redis VectorStore implementation will attempt to generate index schema (fields for filtering) for any metadata passed through the from_texts, from_texts_return_keys, and from_documents methods. This way, whatever metadata is passed will be indexed into the Redis search index allowing for filtering on those fields.\n\nBelow we show what fields were created from the metadata we defined above\n\nrvl index info -i users\n\n    \n    \n    Index Information:\n    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n    â”‚ Index Name   â”‚ Storage Type   â”‚ Prefixes      â”‚ Index Options   â”‚   Indexing â”‚\n    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n    â”‚ users        â”‚ HASH           â”‚ ['doc:users'] â”‚ []              â”‚          0 â”‚\n    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n    Index Fields:\n    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n    â”‚ Name           â”‚ Attribute      â”‚ Type    â”‚ Field Option   â”‚   Option Value â”‚\n    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n    â”‚ user           â”‚ user           â”‚ TEXT    â”‚ WEIGHT         â”‚              1 â”‚\n    â”‚ job            â”‚ job            â”‚ TEXT    â”‚ WEIGHT         â”‚              1 â”‚\n    â”‚ credit_score   â”‚ credit_score   â”‚ TEXT    â”‚ WEIGHT         â”‚              1 â”‚\n    â”‚ content        â”‚ content        â”‚ TEXT    â”‚ WEIGHT         â”‚              1 â”‚\n    â”‚ age            â”‚ age            â”‚ NUMERIC â”‚                â”‚                â”‚\n    â”‚ content_vector â”‚ content_vector â”‚ VECTOR  â”‚                â”‚                â”‚\n    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\nrvl stats -i users\n\n    \n    Statistics:\n    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n    â”‚ Stat Key                    â”‚ Value       â”‚\n    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n    â”‚ num_docs                    â”‚ 5           â”‚\n    â”‚ num_terms                   â”‚ 15          â”‚\n    â”‚ max_doc_id                  â”‚ 5           â”‚\n    â”‚ num_records                 â”‚ 33          â”‚\n    â”‚ percent_indexed             â”‚ 1           â”‚\n    â”‚ hash_indexing_failures      â”‚ 0           â”‚\n    â”‚ number_of_uses              â”‚ 4           â”‚\n    â”‚ bytes_per_record_avg        â”‚ 4.60606     â”‚\n    â”‚ doc_table_size_mb           â”‚ 0.000524521 â”‚\n    â”‚ inverted_sz_mb              â”‚ 0.000144958 â”‚\n    â”‚ key_table_size_mb           â”‚ 0.000193596 â”‚\n    â”‚ offset_bits_per_record_avg  â”‚ 8           â”‚\n    â”‚ offset_vectors_sz_mb        â”‚ 2.19345e-05 â”‚\n    â”‚ offsets_per_term_avg        â”‚ 0.69697     â”‚\n    â”‚ records_per_doc_avg         â”‚ 6.6         â”‚\n    â”‚ sortable_values_size_mb     â”‚ 0           â”‚\n    â”‚ total_indexing_time         â”‚ 0.32        â”‚\n    â”‚ total_inverted_index_blocks â”‚ 16          â”‚\n    â”‚ vector_index_sz_mb          â”‚ 6.0126      â”‚\n    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\n\nIt's important to note that we have not specified that the user, job, credit_score and age in the metadata should be fields within the index, this is because the Redis VectorStore object automatically generate the index schema from the passed metadata. For more information on the generation of index fields, see the API documentation.\n\nQueryingâ€‹\n\nThere are multiple ways to query the Redis VectorStore implementation based on what use case you have:\n\nsimilarity_search: Find the most similar vectors to a given vector.\nsimilarity_search_with_score: Find the most similar vectors to a given vector and return the vector distance\nsimilarity_search_limit_score: Find the most similar vectors to a given vector and limit the number of results to the score_threshold\nsimilarity_search_with_relevance_scores: Find the most similar vectors to a given vector and return the vector similarities\nmax_marginal_relevance_search: Find the most similar vectors to a given vector while also optimizing for diversity\nresults = rds.similarity_search(\"foo\")\nprint(results[0].page_content)\n\n    foo\n\n# return metadata\nresults = rds.similarity_search(\"foo\", k=3)\nmeta = results[1].metadata\nprint(\"Key of the document in Redis: \", meta.pop(\"id\"))\nprint(\"Metadata of the document: \", meta)\n\n    Key of the document in Redis:  doc:users:a70ca43b3a4e4168bae57c78753a200f\n    Metadata of the document:  {'user': 'derrick', 'job': 'doctor', 'credit_score': 'low', 'age': '45'}\n\n# with scores (distances)\nresults = rds.similarity_search_with_score(\"foo\", k=5)\nfor result in results:\n    print(f\"Content: {result[0].page_content} --- Score: {result[1]}\")\n\n    Content: foo --- Score: 0.0\n    Content: foo --- Score: 0.0\n    Content: foo --- Score: 0.0\n    Content: bar --- Score: 0.1566\n    Content: bar --- Score: 0.1566\n\n# limit the vector distance that can be returned\nresults = rds.similarity_search_with_score(\"foo\", k=5, distance_threshold=0.1)\nfor result in results:\n    print(f\"Content: {result[0].page_content} --- Score: {result[1]}\")\n\n    Content: foo --- Score: 0.0\n    Content: foo --- Score: 0.0\n    Content: foo --- Score: 0.0\n\n# with scores\nresults = rds.similarity_search_with_relevance_scores(\"foo\", k=5)\nfor result in results:\n    print(f\"Content: {result[0].page_content} --- Similiarity: {result[1]}\")\n\n    Content: foo --- Similiarity: 1.0\n    Content: foo --- Similiarity: 1.0\n    Content: foo --- Similiarity: 1.0\n    Content: bar --- Similiarity: 0.8434\n    Content: bar --- Similiarity: 0.8434\n\n# limit scores (similarities have to be over .9)\nresults = rds.similarity_search_with_relevance_scores(\"foo\", k=5, score_threshold=0.9)\nfor result in results:\n    print(f\"Content: {result[0].page_content} --- Similarity: {result[1]}\")\n\n    Content: foo --- Similarity: 1.0\n    Content: foo --- Similarity: 1.0\n    Content: foo --- Similarity: 1.0\n\n# you can also add new documents as follows\nnew_document = [\"baz\"]\nnew_metadata = [{\"user\": \"sam\", \"age\": 50, \"job\": \"janitor\", \"credit_score\": \"high\"}]\n# both the document and metadata must be lists\nrds.add_texts(new_document, new_metadata)\n\n    ['doc:users:b9c71d62a0a34241a37950b448dafd38']\n\n# now query the new document\nresults = rds.similarity_search(\"baz\", k=3)\nprint(results[0].metadata)\n\n    {'id': 'doc:users:b9c71d62a0a34241a37950b448dafd38', 'user': 'sam', 'job': 'janitor', 'credit_score': 'high', 'age': '50'}\n\n# use maximal marginal relevance search to diversify results\nresults = rds.max_marginal_relevance_search(\"foo\")\n\n# the lambda_mult parameter controls the diversity of the results, the lower the more diverse\nresults = rds.max_marginal_relevance_search(\"foo\", lambda_mult=0.1)\n\nConnect to an Existing Indexâ€‹\n\nIn order to have the same metadata indexed when using the Redis VectorStore. You will need to have the same index_schema passed in either as a path to a yaml file or as a dictionary. The following shows how to obtain the schema from an index and connect to an existing index.\n\n# write the schema to a yaml file\nrds.write_schema(\"redis_schema.yaml\")\n\n\nThe schema file for this example should look something like:\n\nnumeric:\n- name: age\n  no_index: false\n  sortable: false\ntext:\n- name: user\n  no_index: false\n  no_stem: false\n  sortable: false\n  weight: 1\n  withsuffixtrie: false\n- name: job\n  no_index: false\n  no_stem: false\n  sortable: false\n  weight: 1\n  withsuffixtrie: false\n- name: credit_score\n  no_index: false\n  no_stem: false\n  sortable: false\n  weight: 1\n  withsuffixtrie: false\n- name: content\n  no_index: false\n  no_stem: false\n  sortable: false\n  weight: 1\n  withsuffixtrie: false\nvector:\n- algorithm: FLAT\n  block_size: 1000\n  datatype: FLOAT32\n  dims: 1536\n  distance_metric: COSINE\n  initial_cap: 20000\n  name: content_vector\n\n\nNotice, this include all possible fields for the schema. You can remove any fields that you don't need.\n\n# now we can connect to our existing index as follows\n\nnew_rds = Redis.from_existing_index(\n    embeddings,\n    index_name=\"users\",\n    redis_url=\"redis://localhost:6379\",\n    schema=\"redis_schema.yaml\",\n)\nresults = new_rds.similarity_search(\"foo\", k=3)\nprint(results[0].metadata)\n\n    {'id': 'doc:users:8484c48a032d4c4cbe3cc2ed6845fabb', 'user': 'john', 'job': 'engineer', 'credit_score': 'high', 'age': '18'}\n\n# see the schemas are the same\nnew_rds.schema == rds.schema\n\n    True\n\nCustom Metadata Indexingâ€‹\n\nIn some cases, you may want to control what fields the metadata maps to. For example, you may want the credit_score field to be a categorical field instead of a text field (which is the default behavior for all string fields). In this case, you can use the index_schema parameter in each of the initialization methods above to specify the schema for the index. Custom index schema can either be passed as a dictionary or as a path to a yaml file.\n\nAll arguments in the schema have defaults besides the name, so you can specify only the fields you want to change. All the names correspond to the snake/lowercase versions of the arguments you would use on the command line with redis-cli or in redis-py. For more on the arguments for each field, see the documentation\n\nThe below example shows how to specify the schema for the credit_score field as a Tag (categorical) field instead of a text field.\n\n# index_schema.yml\ntag:\n    - name: credit_score\ntext:\n    - name: user\n    - name: job\nnumeric:\n    - name: age\n\n\nIn Python this would look like:\n\n\nindex_schema = {\n    \"tag\": [{\"name\": \"credit_score\"}],\n    \"text\": [{\"name\": \"user\"}, {\"name\": \"job\"}],\n    \"numeric\": [{\"name\": \"age\"}],\n}\n\n\n\nNotice that only the name field needs to be specified. All other fields have defaults.\n\n# create a new index with the new schema defined above\nindex_schema = {\n    \"tag\": [{\"name\": \"credit_score\"}],\n    \"text\": [{\"name\": \"user\"}, {\"name\": \"job\"}],\n    \"numeric\": [{\"name\": \"age\"}],\n}\n\nrds, keys = Redis.from_texts_return_keys(\n    texts,\n    embeddings,\n    metadatas=metadata,\n    redis_url=\"redis://localhost:6379\",\n    index_name=\"users_modified\",\n    index_schema=index_schema,  # pass in the new index schema\n)\n\n    `index_schema` does not match generated metadata schema.\n    If you meant to manually override the schema, please ignore this message.\n    index_schema: {'tag': [{'name': 'credit_score'}], 'text': [{'name': 'user'}, {'name': 'job'}], 'numeric': [{'name': 'age'}]}\n    generated_schema: {'text': [{'name': 'user'}, {'name': 'job'}, {'name': 'credit_score'}], 'numeric': [{'name': 'age'}], 'tag': []}\n    \n\n\nThe above warning is meant to notify users when they are overriding the default behavior. Ignore it if you are intentionally overriding the behavior.\n\nHybrid Filteringâ€‹\n\nWith the Redis Filter Expression language built into langchain, you can create arbitrarily long chains of hybrid filters that can be used to filter your search results. The expression language is derived from the RedisVL Expression Syntax and is designed to be easy to use and understand.\n\nThe following are the available filter types:\n\nRedisText: Filter by full-text search against metadata fields. Supports exact, fuzzy, and wildcard matching.\nRedisNum: Filter by numeric range against metadata fields.\nRedisTag: Filter by exact match against string based categorical metadata fields. Multiple tags can be specified like \"tag1,tag2,tag3\".\n\nThe following are examples of utilizing these filters.\n\n\nfrom langchain.vectorstores.redis import RedisText, RedisNum, RedisTag\n\n# exact matching\nhas_high_credit = RedisTag(\"credit_score\") == \"high\"\ndoes_not_have_high_credit = RedisTag(\"credit_score\") != \"low\"\n\n# fuzzy matching\njob_starts_with_eng = RedisText(\"job\") % \"eng*\"\njob_is_engineer = RedisText(\"job\") == \"engineer\"\njob_is_not_engineer = RedisText(\"job\") != \"engineer\"\n\n# numeric filtering\nage_is_18 = RedisNum(\"age\") == 18\nage_is_not_18 = RedisNum(\"age\") != 18\nage_is_greater_than_18 = RedisNum(\"age\") > 18\nage_is_less_than_18 = RedisNum(\"age\") < 18\nage_is_greater_than_or_equal_to_18 = RedisNum(\"age\") >= 18\nage_is_less_than_or_equal_to_18 = RedisNum(\"age\") <= 18\n\n\n\nThe RedisFilter class can be used to simplify the import of these filters as follows\n\n\nfrom langchain.vectorstores.redis import RedisFilter\n\n# same examples as above\nhas_high_credit = RedisFilter.tag(\"credit_score\") == \"high\"\ndoes_not_have_high_credit = RedisFilter.num(\"age\") > 8\njob_starts_with_eng = RedisFilter.text(\"job\") % \"eng*\"\n\n\nThe following are examples of using hybrid filter for search\n\nfrom langchain.vectorstores.redis import RedisText\n\nis_engineer = RedisText(\"job\") == \"engineer\"\nresults = rds.similarity_search(\"foo\", k=3, filter=is_engineer)\n\nprint(\"Job:\", results[0].metadata[\"job\"])\nprint(\"Engineers in the dataset:\", len(results))\n\n    Job: engineer\n    Engineers in the dataset: 2\n\n# fuzzy match\nstarts_with_doc = RedisText(\"job\") % \"doc*\"\nresults = rds.similarity_search(\"foo\", k=3, filter=starts_with_doc)\n\nfor result in results:\n    print(\"Job:\", result.metadata[\"job\"])\nprint(\"Jobs in dataset that start with 'doc':\", len(results))\n\n    Job: doctor\n    Job: doctor\n    Jobs in dataset that start with 'doc': 2\n\nfrom langchain.vectorstores.redis import RedisNum\n\nis_over_18 = RedisNum(\"age\") > 18\nis_under_99 = RedisNum(\"age\") < 99\nage_range = is_over_18 & is_under_99\nresults = rds.similarity_search(\"foo\", filter=age_range)\n\nfor result in results:\n    print(\"User:\", result.metadata[\"user\"], \"is\", result.metadata[\"age\"])\n\n    User: derrick is 45\n    User: nancy is 94\n    User: joe is 35\n\n# make sure to use parenthesis around FilterExpressions\n# if initializing them while constructing them\nage_range = (RedisNum(\"age\") > 18) & (RedisNum(\"age\") < 99)\nresults = rds.similarity_search(\"foo\", filter=age_range)\n\nfor result in results:\n    print(\"User:\", result.metadata[\"user\"], \"is\", result.metadata[\"age\"])\n\n    User: derrick is 45\n    User: nancy is 94\n    User: joe is 35\n\nRedis as Retrieverâ€‹\n\nHere we go over different options for using the vector store as a retriever.\n\nThere are three different search methods we can use to do retrieval. By default, it will use semantic similarity.\n\nquery = \"foo\"\nresults = rds.similarity_search_with_score(query, k=3, return_metadata=True)\n\nfor result in results:\n    print(\"Content:\", result[0].page_content, \" --- Score: \", result[1])\n\n    Content: foo  --- Score:  0.0\n    Content: foo  --- Score:  0.0\n    Content: foo  --- Score:  0.0\n\nretriever = rds.as_retriever(search_type=\"similarity\", search_kwargs={\"k\": 4})\n\ndocs = retriever.get_relevant_documents(query)\ndocs\n\n    [Document(page_content='foo', metadata={'id': 'doc:users_modified:988ecca7574048e396756efc0e79aeca', 'user': 'john', 'job': 'engineer', 'credit_score': 'high', 'age': '18'}),\n     Document(page_content='foo', metadata={'id': 'doc:users_modified:009b1afeb4084cc6bdef858c7a99b48e', 'user': 'derrick', 'job': 'doctor', 'credit_score': 'low', 'age': '45'}),\n     Document(page_content='foo', metadata={'id': 'doc:users_modified:7087cee9be5b4eca93c30fbdd09a2731', 'user': 'nancy', 'job': 'doctor', 'credit_score': 'high', 'age': '94'}),\n     Document(page_content='bar', metadata={'id': 'doc:users_modified:01ef6caac12b42c28ad870aefe574253', 'user': 'tyler', 'job': 'engineer', 'credit_score': 'high', 'age': '100'})]\n\n\nThere is also the similarity_distance_threshold retriever which allows the user to specify the vector distance\n\nretriever = rds.as_retriever(\n    search_type=\"similarity_distance_threshold\",\n    search_kwargs={\"k\": 4, \"distance_threshold\": 0.1},\n)\n\ndocs = retriever.get_relevant_documents(query)\ndocs\n\n    [Document(page_content='foo', metadata={'id': 'doc:users_modified:988ecca7574048e396756efc0e79aeca', 'user': 'john', 'job': 'engineer', 'credit_score': 'high', 'age': '18'}),\n     Document(page_content='foo', metadata={'id': 'doc:users_modified:009b1afeb4084cc6bdef858c7a99b48e', 'user': 'derrick', 'job': 'doctor', 'credit_score': 'low', 'age': '45'}),\n     Document(page_content='foo', metadata={'id': 'doc:users_modified:7087cee9be5b4eca93c30fbdd09a2731', 'user': 'nancy', 'job': 'doctor', 'credit_score': 'high', 'age': '94'})]\n\n\nLastly, the similarity_score_threshold allows the user to define the minimum score for similar documents\n\nretriever = rds.as_retriever(\n    search_type=\"similarity_score_threshold\",\n    search_kwargs={\"score_threshold\": 0.9, \"k\": 10},\n)\n\nretriever.get_relevant_documents(\"foo\")\n\n    [Document(page_content='foo', metadata={'id': 'doc:users_modified:988ecca7574048e396756efc0e79aeca', 'user': 'john', 'job': 'engineer', 'credit_score': 'high', 'age': '18'}),\n     Document(page_content='foo', metadata={'id': 'doc:users_modified:009b1afeb4084cc6bdef858c7a99b48e', 'user': 'derrick', 'job': 'doctor', 'credit_score': 'low', 'age': '45'}),\n     Document(page_content='foo', metadata={'id': 'doc:users_modified:7087cee9be5b4eca93c30fbdd09a2731', 'user': 'nancy', 'job': 'doctor', 'credit_score': 'high', 'age': '94'})]\n\nretriever = rds.as_retriever(\n    search_type=\"mmr\", search_kwargs={\"fetch_k\": 20, \"k\": 4, \"lambda_mult\": 0.1}\n)\n\nretriever.get_relevant_documents(\"foo\")\n\n    [Document(page_content='foo', metadata={'id': 'doc:users:8f6b673b390647809d510112cde01a27', 'user': 'john', 'job': 'engineer', 'credit_score': 'high', 'age': '18'}),\n     Document(page_content='bar', metadata={'id': 'doc:users:93521560735d42328b48c9c6f6418d6a', 'user': 'tyler', 'job': 'engineer', 'credit_score': 'high', 'age': '100'}),\n     Document(page_content='foo', metadata={'id': 'doc:users:125ecd39d07845eabf1a699d44134a5b', 'user': 'nancy', 'job': 'doctor', 'credit_score': 'high', 'age': '94'}),\n     Document(page_content='foo', metadata={'id': 'doc:users:d6200ab3764c466082fde3eaab972a2a', 'user': 'derrick', 'job': 'doctor', 'credit_score': 'low', 'age': '45'})]\n\nDelete keys\n\nTo delete your entries you have to address them by their keys.\n\nRedis.delete(keys, redis_url=\"redis://localhost:6379\")\n\n    True\n\n# delete the indices too\nRedis.drop_index(\n    index_name=\"users\", delete_documents=True, redis_url=\"redis://localhost:6379\"\n)\nRedis.drop_index(\n    index_name=\"users_modified\",\n    delete_documents=True,\n    redis_url=\"redis://localhost:6379\",\n)\n\n    True\n\nRedis connection Url examplesâ€‹\n\nValid Redis Url scheme are:\n\nredis:// - Connection to Redis standalone, unencrypted\nrediss:// - Connection to Redis standalone, with TLS encryption\nredis+sentinel:// - Connection to Redis server via Redis Sentinel, unencrypted\nrediss+sentinel:// - Connection to Redis server via Redis Sentinel, booth connections with TLS encryption\n\nMore information about additional connection parameter can be found in the redis-py documentation at https://redis-py.readthedocs.io/en/stable/connections.html\n\n# connection to redis standalone at localhost, db 0, no password\nredis_url = \"redis://localhost:6379\"\n# connection to host \"redis\" port 7379 with db 2 and password \"secret\" (old style authentication scheme without username / pre 6.x)\nredis_url = \"redis://:secret@redis:7379/2\"\n# connection to host redis on default port with user \"joe\", pass \"secret\" using redis version 6+ ACLs\nredis_url = \"redis://joe:secret@redis/0\"\n\n# connection to sentinel at localhost with default group mymaster and db 0, no password\nredis_url = \"redis+sentinel://localhost:26379\"\n# connection to sentinel at host redis with default port 26379 and user \"joe\" with password \"secret\" with default group mymaster and db 0\nredis_url = \"redis+sentinel://joe:secret@redis\"\n# connection to sentinel, no auth with sentinel monitoring group \"zone-1\" and database 2\nredis_url = \"redis+sentinel://redis:26379/zone-1/2\"\n\n# connection to redis standalone at localhost, db 0, no password but with TLS support\nredis_url = \"rediss://localhost:6379\"\n# connection to redis sentinel at localhost and default port, db 0, no password\n# but with TLS support for booth Sentinel and Redis server\nredis_url = \"rediss+sentinel://localhost\"\n\nPrevious\nQdrant\nNext\nRockset"
}