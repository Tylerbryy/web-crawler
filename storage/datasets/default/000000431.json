{
	"title": "Activeloop Deep Memory | ü¶úÔ∏èüîó Langchain",
	"url": "https://python.langchain.com/docs/integrations/retrievers/Activeloop%20DeepMemory+LangChain",
	"html": "ComponentsRetrieversActiveloop Deep Memory\nActiveloop Deep Memory\n\nActiveloop Deep Memory is a suite of tools that enables you to optimize your Vector Store for your use-case and achieve higher accuracy in your LLM apps.\n\nRetrieval-Augmented Generatation (RAG) has recently gained significant attention. As advanced RAG techniques and agents emerge, they expand the potential of what RAGs can accomplish. However, several challenges may limit the integration of RAGs into production. The primary factors to consider when implementing RAGs in production settings are accuracy (recall), cost, and latency. For basic use cases, OpenAI's Ada model paired with a naive similarity search can produce satisfactory results. Yet, for higher accuracy or recall during searches, one might need to employ advanced retrieval techniques. These methods might involve varying data chunk sizes, rewriting queries multiple times, and more, potentially increasing latency and costs. Activeloop's Deep Memory a feature available to Activeloop Deep Lake users, addresses these issuea by introducing a tiny neural network layer trained to match user queries with relevant data from a corpus. While this addition incurs minimal latency during search, it can boost retrieval accuracy by up to 27 % and remains cost-effective and simple to use, without requiring any additional advanced rag techniques.\n\nFor this tutorial we will parse DeepLake documentation, and create a RAG system that could answer the question from the docs.\n\n1. Dataset Creation‚Äã\n\nWe will parse activeloop's docs for this tutorial using BeautifulSoup library and LangChain's document parsers like Html2TextTransformer, AsyncHtmlLoader. So we will need to install the following libraries:\n\npip install tiktoken openai python-dotenv datasets langchain deeplake beautifulsoup4 html2text ragas\n\n\nAlso you'll need to create a Activeloop account.\n\nimport getpass\nimport os\n\nfrom langchain.chains import RetrievalQA\nfrom langchain.embeddings.openai import OpenAIEmbeddings\nfrom langchain.llms import OpenAIChat\nfrom langchain.vectorstores.deeplake import DeepLake\n\nos.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter your OpenAI API token: \")\n# # activeloop token is needed if you are not signed in using CLI: `activeloop login -u <USERNAME> -p <PASSWORD>`\nos.environ[\"ACTIVELOOP_TOKEN\"] = getpass.getpass(\n    \"Enter your ActiveLoop API token: \"\n)  # Get your API token from https://app.activeloop.ai, click on your profile picture in the top right corner, and select \"API Tokens\"\n\ntoken = os.getenv(\"ACTIVELOOP_TOKEN\")\nopenai_embeddings = OpenAIEmbeddings()\n\ndb = DeepLake(\n    dataset_path=f\"hub://{ORG_ID}/deeplake-docs-deepmemory\",  # org_id stands for your username or organization from activeloop\n    embedding=openai_embeddings,\n    runtime={\"tensor_db\": True},\n    token=token,\n    # overwrite=True, # user overwrite flag if you want to overwrite the full dataset\n    read_only=False,\n)\n\n\nparsing all links in the webpage using BeautifulSoup\n\nfrom urllib.parse import urljoin\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef get_all_links(url):\n    response = requests.get(url)\n    if response.status_code != 200:\n        print(f\"Failed to retrieve the page: {url}\")\n        return []\n\n    soup = BeautifulSoup(response.content, \"html.parser\")\n\n    # Finding all 'a' tags which typically contain href attribute for links\n    links = [\n        urljoin(url, a[\"href\"]) for a in soup.find_all(\"a\", href=True) if a[\"href\"]\n    ]\n\n    return links\n\n\nbase_url = \"https://docs.deeplake.ai/en/latest/\"\nall_links = get_all_links(base_url)\n\n\nLoading data:\n\nfrom langchain.document_loaders import AsyncHtmlLoader\n\nloader = AsyncHtmlLoader(all_links)\ndocs = loader.load()\n\n\nConverting data into user readable format:\n\nfrom langchain.document_transformers import Html2TextTransformer\n\nhtml2text = Html2TextTransformer()\ndocs_transformed = html2text.transform_documents(docs)\n\n\nNow, let us chunk further the documents as some of the contain too much text:\n\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nchunk_size = 4096\ndocs_new = []\n\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=chunk_size,\n)\n\nfor doc in docs_transformed:\n    if len(doc.page_content) < chunk_size:\n        docs_new.append(doc)\n    else:\n        docs = text_splitter.create_documents([doc.page_content])\n        docs_new.extend(docs)\n\n\nPopulating VectorStore:\n\ndocs = db.add_documents(docs_new)\n\n2. Generating synthetic queries and training Deep Memory‚Äã\n\nNext step would be to train a deep_memory model that will align your users queries with the dataset that you already have. If you don't have any user queries yet, no worries, we will generate them using LLM!\n\nHere above we showed the overall schema how deep_memory works. So as you can see, in order to train it you need relevence, queries together with corpus data (data that we want to query). Corpus data was already populated in the previous section, here we will be generating questions and relevance.\n\nquestions - is a text of strings, where each string represents a query\nrelevence - contains links to the ground truth for each question. There might be several docs that contain answer to the given question. Because of this relevenve is List[List[tuple[str, float]]], where outer list represents queries and inner list relevent documents. Tuple contains str, float pair where string represent the id of the source doc (corresponds to the id tensor in the dataset), while float corresponds to how much current document is related to the question.\n\nNow, let us generate synthetic questions and relevance:\n\nfrom typing import List\n\nfrom langchain.chains.openai_functions import (\n    create_structured_output_chain,\n)\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.prompts import ChatPromptTemplate, HumanMessagePromptTemplate\nfrom langchain.schema import HumanMessage, SystemMessage\nfrom pydantic import BaseModel, Field\n\n# fetch dataset docs and ids if they exist (optional you can also ingest)\ndocs = db.vectorstore.dataset.text.data(fetch_chunks=True, aslist=True)[\"value\"]\nids = db.vectorstore.dataset.id.data(fetch_chunks=True, aslist=True)[\"value\"]\n\n# If we pass in a model explicitly, we need to make sure it supports the OpenAI function-calling API.\nllm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)\n\n\nclass Questions(BaseModel):\n    \"\"\"Identifying information about a person.\"\"\"\n\n    question: str = Field(..., description=\"Questions about text\")\n\n\nprompt_msgs = [\n    SystemMessage(\n        content=\"You are a world class expert for generating questions based on provided context. \\\n                You make sure the question can be answered by the text.\"\n    ),\n    HumanMessagePromptTemplate.from_template(\n        \"Use the given text to generate a question from the following input: {input}\"\n    ),\n    HumanMessage(content=\"Tips: Make sure to answer in the correct format\"),\n]\nprompt = ChatPromptTemplate(messages=prompt_msgs)\nchain = create_structured_output_chain(Questions, llm, prompt, verbose=True)\n\ntext = \"# Understanding Hallucinations and Bias ## **Introduction** In this lesson, we'll cover the concept of **hallucinations** in LLMs, highlighting their influence on AI applications and demonstrating how to mitigate them using techniques like the retriever's architectures. We'll also explore **bias** within LLMs with examples.\"\nquestions = chain.run(input=text)\nprint(questions)\n\nimport random\n\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom tqdm import tqdm\n\n\ndef generate_queries(docs: List[str], ids: List[str], n: int = 100):\n    questions = []\n    relevances = []\n    pbar = tqdm(total=n)\n    while len(questions) < n:\n        # 1. randomly draw a piece of text and relevance id\n        r = random.randint(0, len(docs) - 1)\n        text, label = docs[r], ids[r]\n\n        # 2. generate queries and assign and relevance id\n        generated_qs = [chain.run(input=text).question]\n        questions.extend(generated_qs)\n        relevances.extend([[(label, 1)] for _ in generated_qs])\n        pbar.update(len(generated_qs))\n        if len(questions) % 10 == 0:\n            print(f\"q: {len(questions)}\")\n    return questions[:n], relevances[:n]\n\n\nchain = create_structured_output_chain(Questions, llm, prompt, verbose=False)\nquestions, relevances = generate_queries(docs, ids, n=200)\n\ntrain_questions, train_relevances = questions[:100], relevances[:100]\ntest_questions, test_relevances = questions[100:], relevances[100:]\n\n\nNow we created 100 training queries as well as 100 queries for testing. Now let us train the deep_memory:\n\njob_id = db.vectorstore.deep_memory.train(\n    queries=train_questions,\n    relevance=train_relevances,\n)\n\n\nLet us track the training progress:\n\ndb.vectorstore.deep_memory.status(\"6538939ca0b69a9ca45c528c\")\n\n    \n    --------------------------------------------------------------\n    |                  6538e02ecda4691033a51c5b                  |\n    --------------------------------------------------------------\n    | status                     | completed                     |\n    --------------------------------------------------------------\n    | progress                   | eta: 1.4 seconds              |\n    |                            | recall@10: 79.00% (+34.00%)   |\n    --------------------------------------------------------------\n    | results                    | recall@10: 79.00% (+34.00%)   |\n    --------------------------------------------------------------\n    \n\n3. Evaluating Deep Memory performance‚Äã\n\nGreat we've trained the model! It's showing some substantial improvement in recall, but how can we use it now and evaluate on unseen new data? In this section we will delve into model evaluation and inference part and see how it can be used with LangChain in order to increase retrieval accuracy\n\n3.1 Deep Memory evaluation‚Äã\n\nFor the beginning we can use deep_memory's builtin evaluation method. It calculates several recall metrics. It can be done easily in a few lines of code.\n\nrecall = db.vectorstore.deep_memory.evaluate(\n    queries=test_questions,\n    relevance=test_relevances,\n)\n\n    \n    Embedding queries took 0.81 seconds\n    ---- Evaluating without model ---- \n    Recall@1:     9.0%\n    Recall@3:     19.0%\n    Recall@5:     24.0%\n    Recall@10:    42.0%\n    Recall@50:    93.0%\n    Recall@100:   98.0%\n    ---- Evaluating with model ---- \n    Recall@1:     19.0%\n    Recall@3:     42.0%\n    Recall@5:     49.0%\n    Recall@10:    69.0%\n    Recall@50:    97.0%\n    Recall@100:   97.0%\n    \n\n\nIt is showing quite substatntial improvement on an unseen test dataset too!!!\n\n3.2 Deep Memory + RAGas‚Äã\nfrom ragas.langchain import RagasEvaluatorChain\nfrom ragas.metrics import (\n    context_recall,\n)\n\n\nLet us convert recall into ground truths:\n\ndef convert_relevance_to_ground_truth(docs, relevance):\n    ground_truths = []\n\n    for rel in relevance:\n        ground_truth = []\n        for doc_id, _ in rel:\n            ground_truth.append(docs[doc_id])\n        ground_truths.append(ground_truth)\n    return ground_truths\n\nground_truths = convert_relevance_to_ground_truth(docs, test_relevances)\n\nfor deep_memory in [False, True]:\n    print(\"\\nEvaluating with deep_memory =\", deep_memory)\n    print(\"===================================\")\n\n    retriever = db.as_retriever()\n    retriever.search_kwargs[\"deep_memory\"] = deep_memory\n\n    qa_chain = RetrievalQA.from_chain_type(\n        llm=OpenAIChat(model=\"gpt-3.5-turbo\"),\n        chain_type=\"stuff\",\n        retriever=retriever,\n        return_source_documents=True,\n    )\n\n    metrics = {\n        \"context_recall_score\": 0,\n    }\n\n    eval_chains = {m.name: RagasEvaluatorChain(metric=m) for m in [context_recall]}\n\n    for question, ground_truth in zip(test_questions, ground_truths):\n        result = qa_chain({\"query\": question})\n        result[\"ground_truths\"] = ground_truth\n        for name, eval_chain in eval_chains.items():\n            score_name = f\"{name}_score\"\n            metrics[score_name] += eval_chain(result)[score_name]\n\n    for metric in metrics:\n        metrics[metric] /= len(test_questions)\n        print(f\"{metric}: {metrics[metric]}\")\n    print(\"===================================\")\n\n    \n    Evaluating with deep_memory = False\n    ===================================\n    context_recall_score = 0.3763423145\n    ===================================\n    \n    Evaluating with deep_memory = True\n    ===================================\n    context_recall_score = 0.5634545323\n    ===================================\n    \n\n3.3 Deep Memory Inference‚Äã\n\nwith deep_memory\n\nretriver = db.as_retriever()\nretriver.search_kwargs[\"deep_memory\"] = True\nretriver.search_kwargs[\"k\"] = 10\n\nquery = \"Deamination of cytidine to uridine on the minus strand of viral DNA results in catastrophic G-to-A mutations in the viral genome.\"\nqa = RetrievalQA.from_chain_type(\n    llm=OpenAIChat(model=\"gpt-4\"), chain_type=\"stuff\", retriever=retriver\n)\nprint(qa.run(query))\n\n    The base htype of the 'video_seq' tensor is 'video'.\n\n\nwithout deep_memory\n\nretriver = db.as_retriever()\nretriver.search_kwargs[\"deep_memory\"] = False\nretriver.search_kwargs[\"k\"] = 10\n\nquery = \"Deamination of cytidine to uridine on the minus strand of viral DNA results in catastrophic G-to-A mutations in the viral genome.\"\nqa = RetrievalQA.from_chain_type(\n    llm=OpenAIChat(model=\"gpt-4\"), chain_type=\"stuff\", retriever=retriver\n)\nqa.run(query)\n\n    The text does not provide information on the base htype of the 'video_seq' tensor.\n\n3.4 Deep Memory cost savings‚Äã\n\nDeep Memory increases retrieval accuracy without altering your existing workflow. Additionally, by reducing the top_k input into the LLM, you can significantly cut inference costs via lower token usage.\n\nPrevious\nRetrievers\nNext\nAmazon Kendra"
}