{
	"title": "MyScale | ü¶úÔ∏èüîó Langchain",
	"url": "https://python.langchain.com/docs/integrations/retrievers/self_query/myscale_self_query",
	"html": "ComponentsRetrieversSelf-querying retrieverMyScale\nMyScale\n\nMyScale is an integrated vector database. You can access your database in SQL and also from here, LangChain. MyScale can make use of various data types and functions for filters. It will boost up your LLM app no matter if you are scaling up your data or expand your system to broader application.\n\nIn the notebook, we'll demo the SelfQueryRetriever wrapped around a MyScale vector store with some extra pieces we contributed to LangChain.\n\nIn short, it can be condensed into 4 points:\n\nAdd contain comparator to match the list of any if there is more than one element matched\nAdd timestamp data type for datetime match (ISO-format, or YYYY-MM-DD)\nAdd like comparator for string pattern search\nAdd arbitrary function capability\nCreating a MyScale vector store‚Äã\n\nMyScale has already been integrated to LangChain for a while. So you can follow this notebook to create your own vectorstore for a self-query retriever.\n\nNote: All self-query retrievers requires you to have lark installed (pip install lark). We use lark for grammar definition. Before you proceed to the next step, we also want to remind you that clickhouse-connect is also needed to interact with your MyScale backend.\n\npip install lark clickhouse-connect\n\n\nIn this tutorial we follow other example's setting and use OpenAIEmbeddings. Remember to get an OpenAI API Key for valid access to LLMs.\n\nimport getpass\nimport os\n\nos.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"OpenAI API Key:\")\nos.environ[\"MYSCALE_HOST\"] = getpass.getpass(\"MyScale URL:\")\nos.environ[\"MYSCALE_PORT\"] = getpass.getpass(\"MyScale Port:\")\nos.environ[\"MYSCALE_USERNAME\"] = getpass.getpass(\"MyScale Username:\")\nos.environ[\"MYSCALE_PASSWORD\"] = getpass.getpass(\"MyScale Password:\")\n\nfrom langchain.embeddings.openai import OpenAIEmbeddings\nfrom langchain.schema import Document\nfrom langchain.vectorstores import MyScale\n\nembeddings = OpenAIEmbeddings()\n\nCreate some sample data‚Äã\n\nAs you can see, the data we created has some differences compared to other self-query retrievers. We replaced the keyword year with date which gives you finer control on timestamps. We also changed the type of the keyword gerne to a list of strings, where an LLM can use a new contain comparator to construct filters. We also provide the like comparator and arbitrary function support to filters, which will be introduced in next few cells.\n\nNow let's look at the data first.\n\ndocs = [\n    Document(\n        page_content=\"A bunch of scientists bring back dinosaurs and mayhem breaks loose\",\n        metadata={\"date\": \"1993-07-02\", \"rating\": 7.7, \"genre\": [\"science fiction\"]},\n    ),\n    Document(\n        page_content=\"Leo DiCaprio gets lost in a dream within a dream within a dream within a ...\",\n        metadata={\"date\": \"2010-12-30\", \"director\": \"Christopher Nolan\", \"rating\": 8.2},\n    ),\n    Document(\n        page_content=\"A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea\",\n        metadata={\"date\": \"2006-04-23\", \"director\": \"Satoshi Kon\", \"rating\": 8.6},\n    ),\n    Document(\n        page_content=\"A bunch of normal-sized women are supremely wholesome and some men pine after them\",\n        metadata={\"date\": \"2019-08-22\", \"director\": \"Greta Gerwig\", \"rating\": 8.3},\n    ),\n    Document(\n        page_content=\"Toys come alive and have a blast doing so\",\n        metadata={\"date\": \"1995-02-11\", \"genre\": [\"animated\"]},\n    ),\n    Document(\n        page_content=\"Three men walk into the Zone, three men walk out of the Zone\",\n        metadata={\n            \"date\": \"1979-09-10\",\n            \"director\": \"Andrei Tarkovsky\",\n            \"genre\": [\"science fiction\", \"adventure\"],\n            \"rating\": 9.9,\n        },\n    ),\n]\nvectorstore = MyScale.from_documents(\n    docs,\n    embeddings,\n)\n\nCreating our self-querying retriever‚Äã\n\nJust like other retrievers... simple and nice.\n\nfrom langchain.chains.query_constructor.base import AttributeInfo\nfrom langchain.llms import OpenAI\nfrom langchain.retrievers.self_query.base import SelfQueryRetriever\n\nmetadata_field_info = [\n    AttributeInfo(\n        name=\"genre\",\n        description=\"The genres of the movie\",\n        type=\"list[string]\",\n    ),\n    # If you want to include length of a list, just define it as a new column\n    # This will teach the LLM to use it as a column when constructing filter.\n    AttributeInfo(\n        name=\"length(genre)\",\n        description=\"The length of genres of the movie\",\n        type=\"integer\",\n    ),\n    # Now you can define a column as timestamp. By simply set the type to timestamp.\n    AttributeInfo(\n        name=\"date\",\n        description=\"The date the movie was released\",\n        type=\"timestamp\",\n    ),\n    AttributeInfo(\n        name=\"director\",\n        description=\"The name of the movie director\",\n        type=\"string\",\n    ),\n    AttributeInfo(\n        name=\"rating\", description=\"A 1-10 rating for the movie\", type=\"float\"\n    ),\n]\ndocument_content_description = \"Brief summary of a movie\"\nllm = OpenAI(temperature=0)\nretriever = SelfQueryRetriever.from_llm(\n    llm, vectorstore, document_content_description, metadata_field_info, verbose=True\n)\n\nTesting it out with self-query retriever's existing functionalities‚Äã\n\nAnd now we can try actually using our retriever!\n\n# This example only specifies a relevant query\nretriever.get_relevant_documents(\"What are some movies about dinosaurs\")\n\n# This example only specifies a filter\nretriever.get_relevant_documents(\"I want to watch a movie rated higher than 8.5\")\n\n# This example specifies a query and a filter\nretriever.get_relevant_documents(\"Has Greta Gerwig directed any movies about women\")\n\n# This example specifies a composite filter\nretriever.get_relevant_documents(\n    \"What's a highly rated (above 8.5) science fiction film?\"\n)\n\n# This example specifies a query and composite filter\nretriever.get_relevant_documents(\n    \"What's a movie after 1990 but before 2005 that's all about toys, and preferably is animated\"\n)\n\nWait a second... what else?\n\nSelf-query retriever with MyScale can do more! Let's find out.\n\n# You can use length(genres) to do anything you want\nretriever.get_relevant_documents(\"What's a movie that have more than 1 genres?\")\n\n# Fine-grained datetime? You got it already.\nretriever.get_relevant_documents(\"What's a movie that release after feb 1995?\")\n\n# Don't know what your exact filter should be? Use string pattern match!\nretriever.get_relevant_documents(\"What's a movie whose name is like Andrei?\")\n\n# Contain works for lists: so you can match a list with contain comparator!\nretriever.get_relevant_documents(\n    \"What's a movie who has genres science fiction and adventure?\"\n)\n\nFilter k‚Äã\n\nWe can also use the self query retriever to specify k: the number of documents to fetch.\n\nWe can do this by passing enable_limit=True to the constructor.\n\nretriever = SelfQueryRetriever.from_llm(\n    llm,\n    vectorstore,\n    document_content_description,\n    metadata_field_info,\n    enable_limit=True,\n    verbose=True,\n)\n\n# This example only specifies a relevant query\nretriever.get_relevant_documents(\"what are two movies about dinosaurs\")\n\nPrevious\nMilvus\nNext\nOpenSearch"
}