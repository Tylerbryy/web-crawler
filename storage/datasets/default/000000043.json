{
	"title": "Pydantic compatibility | 🦜️🔗 Langchain",
	"url": "https://python.langchain.com/docs/guides/pydantic_compatibility",
	"html": "Pydantic compatibility\nPydantic compatibility\nPydantic v2 was released in June, 2023 (https://docs.pydantic.dev/2.0/blog/pydantic-v2-final/)\nv2 contains has a number of breaking changes (https://docs.pydantic.dev/2.0/migration/)\nPydantic v2 and v1 are under the same package name, so both versions cannot be installed at the same time\nLangChain Pydantic migration plan​\n\nAs of langchain>=0.0.267, LangChain will allow users to install either Pydantic V1 or V2.\n\nInternally LangChain will continue to use V1.\nDuring this time, users can pin their pydantic version to v1 to avoid breaking changes, or start a partial migration using pydantic v2 throughout their code, but avoiding mixing v1 and v2 code for LangChain (see below).\n\nUser can either pin to pydantic v1, and upgrade their code in one go once LangChain has migrated to v2 internally, or they can start a partial migration to v2, but must avoid mixing v1 and v2 code for LangChain.\n\nBelow are two examples of showing how to avoid mixing pydantic v1 and v2 code in the case of inheritance and in the case of passing objects to LangChain.\n\nExample 1: Extending via inheritance\n\nYES\n\nfrom pydantic.v1 import root_validator, validator\n\nclass CustomTool(BaseTool): # BaseTool is v1 code\n    x: int = Field(default=1)\n\n    def _run(*args, **kwargs):\n        return \"hello\"\n\n    @validator('x') # v1 code\n    @classmethod\n    def validate_x(cls, x: int) -> int:\n        return 1\n    \n\nCustomTool(\n    name='custom_tool',\n    description=\"hello\",\n    x=1,\n)\n\n\nMixing Pydantic v2 primitives with Pydantic v1 primitives can raise cryptic errors\n\nNO\n\nfrom pydantic import Field, field_validator # pydantic v2\n\nclass CustomTool(BaseTool): # BaseTool is v1 code\n    x: int = Field(default=1)\n\n    def _run(*args, **kwargs):\n        return \"hello\"\n\n    @field_validator('x') # v2 code\n    @classmethod\n    def validate_x(cls, x: int) -> int:\n        return 1\n    \n\nCustomTool( \n    name='custom_tool',\n    description=\"hello\",\n    x=1,\n)\n\n\nExample 2: Passing objects to LangChain\n\nYES\n\nfrom langchain.tools.base import Tool\nfrom pydantic.v1 import BaseModel, Field # <-- Uses v1 namespace\n\nclass CalculatorInput(BaseModel):\n    question: str = Field()\n\nTool.from_function( # <-- tool uses v1 namespace\n    func=lambda question: 'hello',\n    name=\"Calculator\",\n    description=\"useful for when you need to answer questions about math\",\n    args_schema=CalculatorInput\n)\n\n\nNO\n\nfrom langchain.tools.base import Tool\nfrom pydantic import BaseModel, Field # <-- Uses v2 namespace\n\nclass CalculatorInput(BaseModel):\n    question: str = Field()\n\nTool.from_function( # <-- tool uses v1 namespace\n    func=lambda question: 'hello',\n    name=\"Calculator\",\n    description=\"useful for when you need to answer questions about math\",\n    args_schema=CalculatorInput\n)\n\nPrevious\nQA with private data protection\nNext\nSafety"
}