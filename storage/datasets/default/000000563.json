{
	"title": "Ollama | ü¶úÔ∏èüîó Langchain",
	"url": "https://python.langchain.com/docs/integrations/llms/ollama",
	"html": "ComponentsLLMsOllama\nOllama\n\nOllama allows you to run open-source large language models, such as Llama 2, locally.\n\nOllama bundles model weights, configuration, and data into a single package, defined by a Modelfile.\n\nIt optimizes setup and configuration details, including GPU usage.\n\nFor a complete list of supported models and model variants, see the Ollama model library.\n\nSetup‚Äã\n\nFirst, follow these instructions to set up and run a local Ollama instance:\n\nDownload\nFetch a model via ollama pull <model family>\ne.g., for Llama-7b: ollama pull llama2 (see full list here)\nThis will download the most basic version of the model typically (e.g., smallest # parameters and q4_0)\nOn Mac, it will download to\n\n~/.ollama/models/manifests/registry.ollama.ai/library/<model family>/latest\n\nAnd we specify a particular version, e.g., for ollama pull vicuna:13b-v1.5-16k-q4_0\nThe file is here with the model version in place of latest\n\n~/.ollama/models/manifests/registry.ollama.ai/library/vicuna/13b-v1.5-16k-q4_0\n\nYou can easily access models in a few ways:\n\n1/ if the app is running:\n\nAll of your local models are automatically served on localhost:11434\nSelect your model when setting llm = Ollama(..., model=\"<model family>:<version>\")\nIf you set llm = Ollama(..., model=\"<model family\") withoout a version it will simply look for latest\n\n2/ if building from source or just running the binary:\n\nThen you must run ollama serve\nAll of your local models are automatically served on localhost:11434\nThen, select as shown above\nUsage‚Äã\n\nYou can see a full list of supported parameters on the API reference page.\n\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler\nfrom langchain.llms import Ollama\n\nllm = Ollama(\n    model=\"llama2\", callback_manager=CallbackManager([StreamingStdOutCallbackHandler()])\n)\n\n\nWith StreamingStdOutCallbackHandler, you will see tokens streamed.\n\nllm(\"Tell me about the history of AI\")\n\n\nOllama supports embeddings via OllamaEmbeddings:\n\nfrom langchain.embeddings import OllamaEmbeddings\n\noembed = OllamaEmbeddings(base_url=\"http://localhost:11434\", model=\"llama2\")\noembed.embed_query(\"Llamas are social animals and live with others as a herd.\")\n\nRAG‚Äã\n\nWe can use Olama with RAG, just as shown here.\n\nLet's use the 13b model:\n\nollama pull llama2:13b\n\n\nLet's also use local embeddings from OllamaEmbeddings and Chroma.\n\npip install chromadb\n\n# Load web page\nfrom langchain.document_loaders import WebBaseLoader\n\nloader = WebBaseLoader(\"https://lilianweng.github.io/posts/2023-06-23-agent/\")\ndata = loader.load()\n\n# Split into chunks\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1500, chunk_overlap=100)\nall_splits = text_splitter.split_documents(data)\n\n# Embed and store\nfrom langchain.embeddings import (\n    GPT4AllEmbeddings,\n    OllamaEmbeddings,  # We can also try Ollama embeddings\n)\nfrom langchain.vectorstores import Chroma\n\nvectorstore = Chroma.from_documents(documents=all_splits, embedding=GPT4AllEmbeddings())\n\n    Found model file at  /Users/rlm/.cache/gpt4all/ggml-all-MiniLM-L6-v2-f16.bin\n\n\n    objc[77472]: Class GGMLMetalClass is implemented in both /Users/rlm/miniforge3/envs/llama2/lib/python3.9/site-packages/gpt4all/llmodel_DO_NOT_MODIFY/build/libreplit-mainline-metal.dylib (0x17f754208) and /Users/rlm/miniforge3/envs/llama2/lib/python3.9/site-packages/gpt4all/llmodel_DO_NOT_MODIFY/build/libllamamodel-mainline-metal.dylib (0x17fb80208). One of the two will be used. Which one is undefined.\n\n# Retrieve\nquestion = \"How can Task Decomposition be done?\"\ndocs = vectorstore.similarity_search(question)\nlen(docs)\n\n    4\n\n# RAG prompt\nfrom langchain import hub\n\nQA_CHAIN_PROMPT = hub.pull(\"rlm/rag-prompt-llama\")\n\n# LLM\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler\nfrom langchain.llms import Ollama\n\nllm = Ollama(\n    model=\"llama2\",\n    verbose=True,\n    callback_manager=CallbackManager([StreamingStdOutCallbackHandler()]),\n)\n\n# QA chain\nfrom langchain.chains import RetrievalQA\n\nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=vectorstore.as_retriever(),\n    chain_type_kwargs={\"prompt\": QA_CHAIN_PROMPT},\n)\n\nquestion = \"What are the various approaches to Task Decomposition for AI Agents?\"\nresult = qa_chain({\"query\": question})\n\n     There are several approaches to task decomposition for AI agents, including:\n    \n    1. Chain of thought (CoT): This involves instructing the model to \"think step by step\" and use more test-time computation to decompose hard tasks into smaller and simpler steps.\n    2. Tree of thoughts (ToT): This extends CoT by exploring multiple reasoning possibilities at each step, creating a tree structure. The search process can be BFS or DFS with each state evaluated by a classifier or majority vote.\n    3. Using task-specific instructions: For example, \"Write a story outline.\" for writing a novel.\n    4. Human inputs: The agent can receive input from a human operator to perform tasks that require creativity and domain expertise.\n    \n    These approaches allow the agent to break down complex tasks into manageable subgoals, enabling efficient handling of tasks and improving the quality of final results through self-reflection and refinement.\n\n\nYou can also get logging for tokens.\n\nfrom langchain.callbacks.base import BaseCallbackHandler\nfrom langchain.schema import LLMResult\n\n\nclass GenerationStatisticsCallback(BaseCallbackHandler):\n    def on_llm_end(self, response: LLMResult, **kwargs) -> None:\n        print(response.generations[0][0].generation_info)\n\n\ncallback_manager = CallbackManager(\n    [StreamingStdOutCallbackHandler(), GenerationStatisticsCallback()]\n)\n\nllm = Ollama(\n    base_url=\"http://localhost:11434\",\n    model=\"llama2\",\n    verbose=True,\n    callback_manager=callback_manager,\n)\n\nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=vectorstore.as_retriever(),\n    chain_type_kwargs={\"prompt\": QA_CHAIN_PROMPT},\n)\n\nquestion = \"What are the approaches to Task Decomposition?\"\nresult = qa_chain({\"query\": question})\n\n\neval_count / (eval_duration/10e9) gets tok / s\n\n62 / (1313002000 / 1000 / 1000 / 1000)\n\n    47.22003469910937\n\nUsing the Hub for prompt management‚Äã\n\nOpen-source models often benefit from specific prompts.\n\nFor example, Mistral 7b was fine-tuned for chat using the prompt format shown here.\n\nGet the model: ollama pull mistral:7b-instruct\n\n# LLM\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler\nfrom langchain.llms import Ollama\n\nllm = Ollama(\n    model=\"mistral:7b-instruct\",\n    verbose=True,\n    callback_manager=CallbackManager([StreamingStdOutCallbackHandler()]),\n)\n\nfrom langchain import hub\n\nQA_CHAIN_PROMPT = hub.pull(\"rlm/rag-prompt-mistral\")\n\n# QA chain\nfrom langchain.chains import RetrievalQA\n\nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=vectorstore.as_retriever(),\n    chain_type_kwargs={\"prompt\": QA_CHAIN_PROMPT},\n)\n\nquestion = \"What are the various approaches to Task Decomposition for AI Agents?\"\nresult = qa_chain({\"query\": question})\n\n    \n    There are different approaches to Task Decomposition for AI Agents such as Chain of thought (CoT) and Tree of Thoughts (ToT). CoT breaks down big tasks into multiple manageable tasks and generates multiple thoughts per step, while ToT explores multiple reasoning possibilities at each step. Task decomposition can be done by LLM with simple prompting or using task-specific instructions or human inputs.\n\nPrevious\nOctoAI\nNext\nOpaquePrompts"
}