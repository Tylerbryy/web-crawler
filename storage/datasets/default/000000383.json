{
	"title": "Auto-fixing parser | ðŸ¦œï¸ðŸ”— Langchain",
	"url": "https://python.langchain.com/docs/modules/model_io/output_parsers/output_fixing_parser",
	"html": "ModulesModel I/OOutput parsersAuto-fixing parser\nAuto-fixing parser\n\nThis output parser wraps another output parser, and in the event that the first one fails it calls out to another LLM to fix any errors.\n\nBut we can do other things besides throw errors. Specifically, we can pass the misformatted output, along with the formatted instructions, to the model and ask it to fix it.\n\nFor this example, we'll use the above Pydantic output parser. Here's what happens if we pass it a result that does not comply with the schema:\n\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.output_parsers import PydanticOutputParser\nfrom langchain.pydantic_v1 import BaseModel, Field\nfrom typing import List\n\nclass Actor(BaseModel):\n    name: str = Field(description=\"name of an actor\")\n    film_names: List[str] = Field(description=\"list of names of films they starred in\")\n\nactor_query = \"Generate the filmography for a random actor.\"\n\nparser = PydanticOutputParser(pydantic_object=Actor)\n\nmisformatted = \"{'name': 'Tom Hanks', 'film_names': ['Forrest Gump']}\"\n\nparser.parse(misformatted)\n\n    ---------------------------------------------------------------------------\n\n    JSONDecodeError                           Traceback (most recent call last)\n\n    File ~/workplace/langchain/langchain/output_parsers/pydantic.py:23, in PydanticOutputParser.parse(self, text)\n         22     json_str = match.group()\n    ---> 23 json_object = json.loads(json_str)\n         24 return self.pydantic_object.parse_obj(json_object)\n\n\n    File ~/.pyenv/versions/3.9.1/lib/python3.9/json/__init__.py:346, in loads(s, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)\n        343 if (cls is None and object_hook is None and\n        344         parse_int is None and parse_float is None and\n        345         parse_constant is None and object_pairs_hook is None and not kw):\n    --> 346     return _default_decoder.decode(s)\n        347 if cls is None:\n\n\n    File ~/.pyenv/versions/3.9.1/lib/python3.9/json/decoder.py:337, in JSONDecoder.decode(self, s, _w)\n        333 \"\"\"Return the Python representation of ``s`` (a ``str`` instance\n        334 containing a JSON document).\n        335\n        336 \"\"\"\n    --> 337 obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n        338 end = _w(s, end).end()\n\n\n    File ~/.pyenv/versions/3.9.1/lib/python3.9/json/decoder.py:353, in JSONDecoder.raw_decode(self, s, idx)\n        352 try:\n    --> 353     obj, end = self.scan_once(s, idx)\n        354 except StopIteration as err:\n\n\n    JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n\n\n    During handling of the above exception, another exception occurred:\n\n\n    OutputParserException                     Traceback (most recent call last)\n\n    Cell In[6], line 1\n    ----> 1 parser.parse(misformatted)\n\n\n    File ~/workplace/langchain/langchain/output_parsers/pydantic.py:29, in PydanticOutputParser.parse(self, text)\n         27 name = self.pydantic_object.__name__\n         28 msg = f\"Failed to parse {name} from completion {text}. Got: {e}\"\n    ---> 29 raise OutputParserException(msg)\n\n\n    OutputParserException: Failed to parse Actor from completion {'name': 'Tom Hanks', 'film_names': ['Forrest Gump']}. Got: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n\n\nNow we can construct and use a OutputFixingParser. This output parser takes as an argument another output parser but also an LLM with which to try to correct any formatting mistakes.\n\nfrom langchain.output_parsers import OutputFixingParser\n\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n\nnew_parser.parse(misformatted)\n\n    Actor(name='Tom Hanks', film_names=['Forrest Gump'])\n\nPrevious\nEnum parser\nNext\nPydantic (JSON) parser"
}