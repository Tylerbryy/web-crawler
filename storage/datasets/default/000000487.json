{
	"title": "Human-in-the-loop Tool Validation | ðŸ¦œï¸ðŸ”— Langchain",
	"url": "https://python.langchain.com/docs/modules/agents/tools/human_approval",
	"html": "ModulesAgentsToolsHuman-in-the-loop Tool Validation\nHuman-in-the-loop Tool Validation\n\nThis walkthrough demonstrates how to add human validation to any Tool. We'll do this using the HumanApprovalCallbackhandler.\n\nLet's suppose we need to make use of the ShellTool. Adding this tool to an automated flow poses obvious risks. Let's see how we could enforce manual human approval of inputs going into this tool.\n\nNote: We generally recommend against using the ShellTool. There's a lot of ways to misuse it, and it's not required for most use cases. We employ it here only for demonstration purposes.\n\nfrom langchain.callbacks import HumanApprovalCallbackHandler\nfrom langchain.tools import ShellTool\n\ntool = ShellTool()\n\nprint(tool.run(\"echo Hello World!\"))\n\n    Hello World!\n    \n\nAdding Human Approvalâ€‹\n\nAdding the default HumanApprovalCallbackHandler to the tool will make it so that a user has to manually approve every input to the tool before the command is actually executed.\n\ntool = ShellTool(callbacks=[HumanApprovalCallbackHandler()])\n\nprint(tool.run(\"ls /usr\"))\n\n    Do you approve of the following input? Anything except 'Y'/'Yes' (case-insensitive) will be treated as a no.\n    \n    ls /usr\n    yes\n    X11\n    X11R6\n    bin\n    lib\n    libexec\n    local\n    sbin\n    share\n    standalone\n    \n\nprint(tool.run(\"ls /private\"))\n\n    Do you approve of the following input? Anything except 'Y'/'Yes' (case-insensitive) will be treated as a no.\n    \n    ls /private\n    no\n\n\n\n    ---------------------------------------------------------------------------\n\n    HumanRejectedException                    Traceback (most recent call last)\n\n    Cell In[17], line 1\n    ----> 1 print(tool.run(\"ls /private\"))\n\n\n    File ~/langchain/langchain/tools/base.py:257, in BaseTool.run(self, tool_input, verbose, start_color, color, callbacks, **kwargs)\n        255 # TODO: maybe also pass through run_manager is _run supports kwargs\n        256 new_arg_supported = signature(self._run).parameters.get(\"run_manager\")\n    --> 257 run_manager = callback_manager.on_tool_start(\n        258     {\"name\": self.name, \"description\": self.description},\n        259     tool_input if isinstance(tool_input, str) else str(tool_input),\n        260     color=start_color,\n        261     **kwargs,\n        262 )\n        263 try:\n        264     tool_args, tool_kwargs = self._to_args_and_kwargs(parsed_input)\n\n\n    File ~/langchain/langchain/callbacks/manager.py:672, in CallbackManager.on_tool_start(self, serialized, input_str, run_id, parent_run_id, **kwargs)\n        669 if run_id is None:\n        670     run_id = uuid4()\n    --> 672 _handle_event(\n        673     self.handlers,\n        674     \"on_tool_start\",\n        675     \"ignore_agent\",\n        676     serialized,\n        677     input_str,\n        678     run_id=run_id,\n        679     parent_run_id=self.parent_run_id,\n        680     **kwargs,\n        681 )\n        683 return CallbackManagerForToolRun(\n        684     run_id, self.handlers, self.inheritable_handlers, self.parent_run_id\n        685 )\n\n\n    File ~/langchain/langchain/callbacks/manager.py:157, in _handle_event(handlers, event_name, ignore_condition_name, *args, **kwargs)\n        155 except Exception as e:\n        156     if handler.raise_error:\n    --> 157         raise e\n        158     logging.warning(f\"Error in {event_name} callback: {e}\")\n\n\n    File ~/langchain/langchain/callbacks/manager.py:139, in _handle_event(handlers, event_name, ignore_condition_name, *args, **kwargs)\n        135 try:\n        136     if ignore_condition_name is None or not getattr(\n        137         handler, ignore_condition_name\n        138     ):\n    --> 139         getattr(handler, event_name)(*args, **kwargs)\n        140 except NotImplementedError as e:\n        141     if event_name == \"on_chat_model_start\":\n\n\n    File ~/langchain/langchain/callbacks/human.py:48, in HumanApprovalCallbackHandler.on_tool_start(self, serialized, input_str, run_id, parent_run_id, **kwargs)\n         38 def on_tool_start(\n         39     self,\n         40     serialized: Dict[str, Any],\n       (...)\n         45     **kwargs: Any,\n         46 ) -> Any:\n         47     if self._should_check(serialized) and not self._approve(input_str):\n    ---> 48         raise HumanRejectedException(\n         49             f\"Inputs {input_str} to tool {serialized} were rejected.\"\n         50         )\n\n\n    HumanRejectedException: Inputs ls /private to tool {'name': 'terminal', 'description': 'Run shell commands on this MacOS machine.'} were rejected.\n\nConfiguring Human Approvalâ€‹\n\nLet's suppose we have an agent that takes in multiple tools, and we want it to only trigger human approval requests on certain tools and certain inputs. We can configure out callback handler to do just this.\n\nfrom langchain.agents import AgentType, initialize_agent, load_tools\nfrom langchain.llms import OpenAI\n\ndef _should_check(serialized_obj: dict) -> bool:\n    # Only require approval on ShellTool.\n    return serialized_obj.get(\"name\") == \"terminal\"\n\n\ndef _approve(_input: str) -> bool:\n    if _input == \"echo 'Hello World'\":\n        return True\n    msg = (\n        \"Do you approve of the following input? \"\n        \"Anything except 'Y'/'Yes' (case-insensitive) will be treated as a no.\"\n    )\n    msg += \"\\n\\n\" + _input + \"\\n\"\n    resp = input(msg)\n    return resp.lower() in (\"yes\", \"y\")\n\n\ncallbacks = [HumanApprovalCallbackHandler(should_check=_should_check, approve=_approve)]\n\nllm = OpenAI(temperature=0)\ntools = load_tools([\"wikipedia\", \"llm-math\", \"terminal\"], llm=llm)\nagent = initialize_agent(\n    tools,\n    llm,\n    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,\n)\n\nagent.run(\n    \"It's 2023 now. How many years ago did Konrad Adenauer become Chancellor of Germany.\",\n    callbacks=callbacks,\n)\n\n    'Konrad Adenauer became Chancellor of Germany in 1949, 74 years ago.'\n\nagent.run(\"print 'Hello World' in the terminal\", callbacks=callbacks)\n\n    'Hello World'\n\nagent.run(\"list all directories in /private\", callbacks=callbacks)\n\n    Do you approve of the following input? Anything except 'Y'/'Yes' (case-insensitive) will be treated as a no.\n    \n    ls /private\n    no\n\n\n\n    ---------------------------------------------------------------------------\n\n    HumanRejectedException                    Traceback (most recent call last)\n\n    Cell In[39], line 1\n    ----> 1 agent.run(\"list all directories in /private\", callbacks=callbacks)\n\n\n    File ~/langchain/langchain/chains/base.py:236, in Chain.run(self, callbacks, *args, **kwargs)\n        234     if len(args) != 1:\n        235         raise ValueError(\"`run` supports only one positional argument.\")\n    --> 236     return self(args[0], callbacks=callbacks)[self.output_keys[0]]\n        238 if kwargs and not args:\n        239     return self(kwargs, callbacks=callbacks)[self.output_keys[0]]\n\n\n    File ~/langchain/langchain/chains/base.py:140, in Chain.__call__(self, inputs, return_only_outputs, callbacks)\n        138 except (KeyboardInterrupt, Exception) as e:\n        139     run_manager.on_chain_error(e)\n    --> 140     raise e\n        141 run_manager.on_chain_end(outputs)\n        142 return self.prep_outputs(inputs, outputs, return_only_outputs)\n\n\n    File ~/langchain/langchain/chains/base.py:134, in Chain.__call__(self, inputs, return_only_outputs, callbacks)\n        128 run_manager = callback_manager.on_chain_start(\n        129     {\"name\": self.__class__.__name__},\n        130     inputs,\n        131 )\n        132 try:\n        133     outputs = (\n    --> 134         self._call(inputs, run_manager=run_manager)\n        135         if new_arg_supported\n        136         else self._call(inputs)\n        137     )\n        138 except (KeyboardInterrupt, Exception) as e:\n        139     run_manager.on_chain_error(e)\n\n\n    File ~/langchain/langchain/agents/agent.py:953, in AgentExecutor._call(self, inputs, run_manager)\n        951 # We now enter the agent loop (until it returns something).\n        952 while self._should_continue(iterations, time_elapsed):\n    --> 953     next_step_output = self._take_next_step(\n        954         name_to_tool_map,\n        955         color_mapping,\n        956         inputs,\n        957         intermediate_steps,\n        958         run_manager=run_manager,\n        959     )\n        960     if isinstance(next_step_output, AgentFinish):\n        961         return self._return(\n        962             next_step_output, intermediate_steps, run_manager=run_manager\n        963         )\n\n\n    File ~/langchain/langchain/agents/agent.py:820, in AgentExecutor._take_next_step(self, name_to_tool_map, color_mapping, inputs, intermediate_steps, run_manager)\n        818         tool_run_kwargs[\"llm_prefix\"] = \"\"\n        819     # We then call the tool on the tool input to get an observation\n    --> 820     observation = tool.run(\n        821         agent_action.tool_input,\n        822         verbose=self.verbose,\n        823         color=color,\n        824         callbacks=run_manager.get_child() if run_manager else None,\n        825         **tool_run_kwargs,\n        826     )\n        827 else:\n        828     tool_run_kwargs = self.agent.tool_run_logging_kwargs()\n\n\n    File ~/langchain/langchain/tools/base.py:257, in BaseTool.run(self, tool_input, verbose, start_color, color, callbacks, **kwargs)\n        255 # TODO: maybe also pass through run_manager is _run supports kwargs\n        256 new_arg_supported = signature(self._run).parameters.get(\"run_manager\")\n    --> 257 run_manager = callback_manager.on_tool_start(\n        258     {\"name\": self.name, \"description\": self.description},\n        259     tool_input if isinstance(tool_input, str) else str(tool_input),\n        260     color=start_color,\n        261     **kwargs,\n        262 )\n        263 try:\n        264     tool_args, tool_kwargs = self._to_args_and_kwargs(parsed_input)\n\n\n    File ~/langchain/langchain/callbacks/manager.py:672, in CallbackManager.on_tool_start(self, serialized, input_str, run_id, parent_run_id, **kwargs)\n        669 if run_id is None:\n        670     run_id = uuid4()\n    --> 672 _handle_event(\n        673     self.handlers,\n        674     \"on_tool_start\",\n        675     \"ignore_agent\",\n        676     serialized,\n        677     input_str,\n        678     run_id=run_id,\n        679     parent_run_id=self.parent_run_id,\n        680     **kwargs,\n        681 )\n        683 return CallbackManagerForToolRun(\n        684     run_id, self.handlers, self.inheritable_handlers, self.parent_run_id\n        685 )\n\n\n    File ~/langchain/langchain/callbacks/manager.py:157, in _handle_event(handlers, event_name, ignore_condition_name, *args, **kwargs)\n        155 except Exception as e:\n        156     if handler.raise_error:\n    --> 157         raise e\n        158     logging.warning(f\"Error in {event_name} callback: {e}\")\n\n\n    File ~/langchain/langchain/callbacks/manager.py:139, in _handle_event(handlers, event_name, ignore_condition_name, *args, **kwargs)\n        135 try:\n        136     if ignore_condition_name is None or not getattr(\n        137         handler, ignore_condition_name\n        138     ):\n    --> 139         getattr(handler, event_name)(*args, **kwargs)\n        140 except NotImplementedError as e:\n        141     if event_name == \"on_chat_model_start\":\n\n\n    File ~/langchain/langchain/callbacks/human.py:48, in HumanApprovalCallbackHandler.on_tool_start(self, serialized, input_str, run_id, parent_run_id, **kwargs)\n         38 def on_tool_start(\n         39     self,\n         40     serialized: Dict[str, Any],\n       (...)\n         45     **kwargs: Any,\n         46 ) -> Any:\n         47     if self._should_check(serialized) and not self._approve(input_str):\n    ---> 48         raise HumanRejectedException(\n         49             f\"Inputs {input_str} to tool {serialized} were rejected.\"\n         50         )\n\n\n    HumanRejectedException: Inputs ls /private to tool {'name': 'terminal', 'description': 'Run shell commands on this MacOS machine.'} were rejected.\n\nPrevious\nDefining Custom Tools\nNext\nMulti-Input Tools"
}