{
	"title": "Text splitting by header | ü¶úÔ∏èüîó Langchain",
	"url": "https://python.langchain.com/docs/use_cases/question_answering/document-context-aware-QA",
	"html": "Retrieval-augmented generation (RAG)Text splitting by header\nText splitting by header\n\nText splitting for vector storage often uses sentences or other delimiters to keep related text together.\n\nBut many documents (such as Markdown files) have structure (headers) that can be explicitly used in splitting.\n\nThe MarkdownHeaderTextSplitter lets a user split Markdown files files based on specified headers.\n\nThis results in chunks that retain the header(s) that it came from in the metadata.\n\nThis works nicely w/ SelfQueryRetriever.\n\nFirst, tell the retriever about our splits.\n\nThen, query based on the doc structure (e.g., \"summarize the doc introduction\").\n\nChunks only from that section of the Document will be filtered and used in chat / Q+A.\n\nLet's test this out on an example Notion page!\n\nFirst, I download the page to Markdown as explained here.\n\n# Load Notion page as a markdownfile file\nfrom langchain.document_loaders import NotionDirectoryLoader\n\npath = \"../Notion_DB/\"\nloader = NotionDirectoryLoader(path)\ndocs = loader.load()\nmd_file = docs[0].page_content\n\n# Let's create groups based on the section headers in our page\nfrom langchain.text_splitter import MarkdownHeaderTextSplitter\n\nheaders_to_split_on = [\n    (\"###\", \"Section\"),\n]\nmarkdown_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=headers_to_split_on)\nmd_header_splits = markdown_splitter.split_text(md_file)\n\n\nNow, perform text splitting on the header grouped documents.\n\n# Define our text splitter\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nchunk_size = 500\nchunk_overlap = 0\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=chunk_size, chunk_overlap=chunk_overlap\n)\nall_splits = text_splitter.split_documents(md_header_splits)\n\n\nThis sets us up well do perform metadata filtering based on the document structure.\n\nLet's bring this all together by building a vectorstore first.\n\npip install chromadb\n\n# Build vectorstore and keep the metadata\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.vectorstores import Chroma\n\nvectorstore = Chroma.from_documents(documents=all_splits, embedding=OpenAIEmbeddings())\n\n\nLet's create a SelfQueryRetriever that can filter based upon metadata we defined.\n\n# Create retriever\nfrom langchain.chains.query_constructor.base import AttributeInfo\nfrom langchain.llms import OpenAI\nfrom langchain.retrievers.self_query.base import SelfQueryRetriever\n\n# Define our metadata\nmetadata_field_info = [\n    AttributeInfo(\n        name=\"Section\",\n        description=\"Part of the document that the text comes from\",\n        type=\"string or list[string]\",\n    ),\n]\ndocument_content_description = \"Major sections of the document\"\n\n# Define self query retriever\nllm = OpenAI(temperature=0)\nretriever = SelfQueryRetriever.from_llm(\n    llm, vectorstore, document_content_description, metadata_field_info, verbose=True\n)\n\n\nWe can see that we can query only for texts in the Introduction of the document!\n\n# Test\nretriever.get_relevant_documents(\"Summarize the Introduction section of the document\")\n\n    query='Introduction' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Introduction') limit=None\n\n\n\n\n\n    [Document(page_content='![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled.png)', metadata={'Section': 'Introduction'}),\n     Document(page_content='Q+A systems often use a two-step approach: retrieve relevant text chunks and then synthesize them into an answer. There many ways to approach this. For example, we recently [discussed](https://blog.langchain.dev/auto-evaluation-of-anthropic-100k-context-window/) the Retriever-Less option (at bottom in the below diagram), highlighting the Anthropic 100k context window model. Metadata filtering is an alternative approach that pre-filters chunks based on a user-defined criteria in a VectorDB using', metadata={'Section': 'Introduction'}),\n     Document(page_content='metadata tags prior to semantic search.', metadata={'Section': 'Introduction'})]\n\n# Test\nretriever.get_relevant_documents(\"Summarize the Introduction section of the document\")\n\n    query='Introduction' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Introduction') limit=None\n\n\n\n\n\n    [Document(page_content='![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled.png)', metadata={'Section': 'Introduction'}),\n     Document(page_content='Q+A systems often use a two-step approach: retrieve relevant text chunks and then synthesize them into an answer. There many ways to approach this. For example, we recently [discussed](https://blog.langchain.dev/auto-evaluation-of-anthropic-100k-context-window/) the Retriever-Less option (at bottom in the below diagram), highlighting the Anthropic 100k context window model. Metadata filtering is an alternative approach that pre-filters chunks based on a user-defined criteria in a VectorDB using', metadata={'Section': 'Introduction'}),\n     Document(page_content='metadata tags prior to semantic search.', metadata={'Section': 'Introduction'})]\n\n\nWe can also look at other parts of the document.\n\nretriever.get_relevant_documents(\"Summarize the Testing section of the document\")\n\n    query='Testing' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Testing') limit=None\n\n\n\n\n\n    [Document(page_content='![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled%202.png)', metadata={'Section': 'Testing'}),\n     Document(page_content='`SelfQueryRetriever` works well in [many cases](https://twitter.com/hwchase17/status/1656791488569954304/photo/1). For example, given [this test case](https://twitter.com/hwchase17/status/1656791488569954304?s=20):  \\n![Untitled](Auto-Evaluation%20of%20Metadata%20Filtering%2018502448c85240828f33716740f9574b/Untitled%201.png)  \\nThe query can be nicely broken up into semantic query and metadata filter:  \\n```python\\nsemantic query: \"prompt injection\"', metadata={'Section': 'Testing'}),\n     Document(page_content='Below, we can see detailed results from the app:  \\n- Kor extraction is above to perform the transformation between query and metadata format ‚úÖ\\n- Self-querying attempts to filter using the episode ID (`252`) in the query and fails üö´\\n- Baseline returns docs from 3 different episodes (one from `252`), confusing the answer üö´', metadata={'Section': 'Testing'}),\n     Document(page_content='will use in retrieval [here](https://github.com/langchain-ai/auto-evaluator/blob/main/streamlit/kor_retriever_lex.py).', metadata={'Section': 'Testing'})]\n\n\nNow, we can create chat or Q+A apps that are aware of the explicit document structure.\n\nThe ability to retain document structure for metadata filtering can be helpful for complicated or longer documents.\n\nfrom langchain.chains import RetrievalQA\nfrom langchain.chat_models import ChatOpenAI\n\nllm = ChatOpenAI(model_name=\"gpt-3.5-turbo\", temperature=0)\nqa_chain = RetrievalQA.from_chain_type(llm, retriever=retriever)\nqa_chain.run(\"Summarize the Testing section of the document\")\n\n    query='Testing' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='Section', value='Testing') limit=None\n\n\n\n\n\n    'The Testing section of the document describes the evaluation of the `SelfQueryRetriever` component in comparison to a baseline model. The evaluation was performed on a test case where the query was broken down into a semantic query and a metadata filter. The results showed that the `SelfQueryRetriever` component was able to perform the transformation between query and metadata format, but failed to filter using the episode ID in the query. The baseline model returned documents from three different episodes, which confused the answer. The `SelfQueryRetriever` component was deemed to work well in many cases and will be used in retrieval.'\n\nPrevious\nRAG with Agents\nNext\nRAG using local models"
}